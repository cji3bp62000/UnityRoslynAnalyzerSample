using System;
using System.Buffers;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace SourceGeneratorPlayground;

[Generator]
public class RecordUnpackerIncrementalSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // RecordBase から継承したクラスをフィルターする
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.isTargetClass)
            .Select((t, _) => t.Item1);

        // ソースコードを生成する
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    /// <summary>
    /// クラスが RecordBase から継承しているかどうかを確認する
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>結果</returns>
    private static (ClassDeclarationSyntax, bool isTargetClass) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax) context.Node;

        if (context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
            return (classDeclarationSyntax, false);
        // dont generate for RecordBase
        if (classSymbol.Name is "RecordBase")
            return (classDeclarationSyntax, false);
        if (GetRootTypeSymbolExceptObject(classSymbol).Name is "RecordBase")
            return (classDeclarationSyntax, true);
        return (classDeclarationSyntax, false);
    }

    /// <summary>
    /// RecordUnpacker クラスを生成する
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        // GetClassDeclarationForSourceGen で確認した対象クラスに対して生成する
        foreach (var classDeclarationSyntax in classDeclarations) {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // クラスが取得できない場合はスキップ
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            // クラス名を取得する
            var className = classDeclarationSyntax.Identifier.Text;

            // 対象のプロパティを取得する
            var targetProperties = classSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(IsTargetProperty)
                .ToArray();

            // ソースコードを構築する
            var code = $@"// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Text;

/*
record name: {classSymbol.Name} 
properties:
{string.Join("\n", targetProperties.Select(p => $"- {p.Name} (type: {p.Type.ToDisplayString()})"))}
*/

// ------------------------------------

namespace MsgPack.RecordUnpackers
{{
    public sealed class {className}Unpacker : RecordUnpackerBase<{className}Unpacker, {classSymbol.ToDisplayString()}>
    {{
{string.Join("\n", targetProperties.Select((p, i) => $"        private static readonly Memory<byte> {p.Name}NameByte = Encoding.UTF8.GetBytes(nameof({p.ToDisplayString()}));"))}

        private static readonly Dictionary<Memory<byte>, int> nameIndexDic = new()
        {{
{string.Join("\n", targetProperties.Select((p, i) => $"            [{p.Name}NameByte] = {i},"))}
        }};

        protected sealed override Dictionary<Memory<byte>, int> GetNameIndexDic() => nameIndexDic;

        protected sealed override bool TryUnpackByIndex(int index, Span<byte> nameSpan, ObjectPacker packer, MsgPackReader reader, {classSymbol.ToDisplayString()} record,
            bool isIndexAlreadyChecked = false)
        {{
            switch (index) {{
{string.Join("\n", targetProperties.Select(ConstructPropertyUnpackSourceCode))}
            }}

            return false;
        }}
    }}
}}
";

            // ソースコードを追加する
            context.AddSource($"{className}Unpacker.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    /// <summary>
    /// 一番上の継承元の型を取得する（System.Object 除く）
    /// </summary>
    /// <param name="symbol">確認する型</param>
    /// <returns>一番上の継承元の型</returns>
    private static INamedTypeSymbol GetRootTypeSymbolExceptObject(INamedTypeSymbol symbol)
    {
        var rootTypeSymbol = symbol;
        while (rootTypeSymbol.BaseType != null && rootTypeSymbol.BaseType.Name != "Object") {
            rootTypeSymbol = rootTypeSymbol.BaseType;
        }

        return rootTypeSymbol;
    }

    /// <summary>
    /// msgpack 対象のプロパティかどうかを判定する
    /// </summary>
    /// <param name="propertySymbol">判定するプロパティ</param>
    /// <returns>対象のプロパティかどうか</returns>
    private static bool IsTargetProperty(IPropertySymbol propertySymbol)
    {
        return propertySymbol.DeclaredAccessibility is Accessibility.Public &&
            !propertySymbol.IsStatic &&
            propertySymbol.GetMethod?.DeclaredAccessibility is Accessibility.Public or Accessibility.NotApplicable
            && propertySymbol.SetMethod?.DeclaredAccessibility is Accessibility.Public or Accessibility.NotApplicable;
    }

    /// <summary>
    /// 各プロパティの switch-case 文を生成する
    /// </summary>
    /// <param name="propertySymbol">プロパティのシンボル</param>
    /// <param name="index">順番</param>
    /// <returns>文</returns>
    private static string ConstructPropertyUnpackSourceCode(IPropertySymbol propertySymbol, int index)
    {
        var (readMethodName, isUnknownType) = GetReadMethodName(propertySymbol);
        var castExpression = isUnknownType ? $"({propertySymbol.Type.ToDisplayString()}) " : "";
        return$@"
                // {propertySymbol.Name} (type: {propertySymbol.Type.ToDisplayString()})
                case {index}:
                    if (isIndexAlreadyChecked || {propertySymbol.Name}NameByte.Span.SequenceEqual(nameSpan)) {{
                        record.{propertySymbol.Name} = {castExpression}{readMethodName}(packer, reader);
                    }}
                    return true;";

        // プロパティの型に応じて専用の MsgPack 読み込み関数を使用する
        (string readMethodName, bool isUnknownType) GetReadMethodName(IPropertySymbol p)
        {
            // 既知の型は専用関数を使用する
            switch (p.Type.ToDisplayString()) {
                case "int":
                    return ("ReadInt", false);
                case "long":
                    return ("ReadLong", false);
                case "float":
                    return ("ReadFloat", false);
                case "double":
                    return ("ReadDouble", false);
                case "string":
                    return ("ReadString", false);
                case "System.DateTime":
                    return ("ReadDateTime", false);
                case "System.DateTimeOffset":
                    return ("ReadDateTimeOffset", false);

                default:
                    break;
            }

            // 未知の型は object として扱う
            return ("ReadUnknownType", true);
        }
    }
}